const checkMassiveStock = async (req, res) => {
  const { dataQte } = req.body;

  if (!Array.isArray(dataQte) || dataQte.length === 0) {
    return res
      .status(400)
      .json({ message: "data to check must be not empty!" });
  }

  const results = [];

  try {
    for (const element of dataQte) {
      try {
        const gammeFromDB = await gamme.findOne({
          where: { partNumber: element.partNumber },
        });

        if (!gammeFromDB) {
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: false,
            reason: "gamme not found",
          });
          continue;
        }

        const patternFromDB = await pattern.findOne({
          where: {
            id_gamme: gammeFromDB.id,
            patternNumb: element.patternNumb,
          },
        });

        if (!patternFromDB) {
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: false,
          });
          continue;
        }

        const binFromDB = await bins.findOne({
          where: {
            bin_code: element.bin_code,
            status: {
              [Op.in]: ["Réservé", "Vide"],
            },
          },
        });

        if (!binFromDB) {
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: false,
          });
          continue;
        }

        const pattern_binFromDB = await pattern_bin.findOne({
          where: {
            patternId: patternFromDB.id,
            binId: binFromDB.id,
          },
        });

        if (!pattern_binFromDB) {
          const countPatternInBins = await pattern_bin.count({
            where: {
              binId: binFromDB?.id,
            },
          });

          if (countPatternInBins === 0) {
            await bins.update(
              { status: "Réservé" },
              {
                where: {
                  bin_code: binFromDB?.bin_code,
                  status: "Vide",
                },
              }
            );
          }

          const newBin = await pattern_bin.create({
            binId: binFromDB?.id,
            patternId: patternFromDB?.id,
          });

          const deletedRowsCount = await pattern_bin.destroy({
            where: {
              binId: binFromDB?.id,
              patternId: patternFromDB?.id,
            },
          });
          if (deletedRowsCount > 0) {
            const countPatternInBins = await pattern_bin.count({
              where: {
                binId: binFromDB?.id,
              },
            });
            if (countPatternInBins === 0) {
              await bins.update(
                { status: "Vide" },
                {
                  where: {
                    bin_code: binFromDB?.bin_code,
                  },
                }
              );
            }
          }
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: true,
            binChangement: [newBin?.bin_code, element.bin_code],
          });
        } else {
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: false,
          });
        }

        if (Number(patternFromDB.quantite) !== Number(element.quantite)) {
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: true,
            qteChangement: [patternFromDB.quantite, Number(element.quantite)],
          });
        } else {
          results.push({
            partNumber: element.partNumber,
            pattern: element.patternNumb,
            updated: false,
          });
        }
      } catch (error) {
        console.log("Error updating element:", element, error);
        results.push({
          partNumber: element.partNumber,
          pattern: element.patternNumb,
          updated: false,
        });
      }
    }

    const updated = results.filter((r) => r.updated).length;
    const finalResult = results.filter((r) => r.updated);
    res.status(200).json({
      message: "Check process completed",
      updated,
      details: finalResult,
    });
  } catch (error) {
    console.error("Massive update error:", error);
    res.status(500).json({
      message: "Server error during massive update",
      error: error.message,
    });
  }
};